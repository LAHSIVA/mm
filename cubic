'''
import numpy as np
import matplotlib.pyplot as plt

# Function
def f(x):
    return np.sin(x)

# Trapezoidal Rule:
def trapezoidal(f, a, b, n):
    
    h = (b-a)/n
    x = np.linspace(a, b, n+1)
    y = f(x)

    result = (h/2) * (y[0] + 2*sum(y[1:-1]) + y[-1])
    return result


# Simpson's 1/3 Rule:
def simpsons(f, a, b, n):

    if n%2 != 0:
        raise ValueError("n must be even")

    h = (b-a)/n
    x = np.linspace(a, b, n+1)
    y = f(x)

    result = (h/3) * (y[0] + 4*sum(y[1:-1:2]) + 2*sum(y[2:-2:2]) + y[-1])
    return result

# Problem setup
a, b = 0, np.pi
true_value = 2.0

n = 20

trapezoidal_result = trapezoidal(f, a, b, n)
simpsons_result = simpsons(f, a, b, n)

print(f"Composite Trapezoidal (n={n}):", trapezoidal_result, "Error =", abs(true_value - trapezoidal_result))
print(f"Composite Simpson's (n={n}):", simpsons_result, "Error =", abs(true_value - simpsons_result))

# Plot
x_vals = np.linspace(a, b, 500)
plt.plot(x_vals, f(x_vals), 'b', label="sin(x)")
plt.fill_between(x_vals, f(x_vals), color='skyblue', alpha=0.4, label="Exact area")
plt.title("Integration of sin(x) from 0 to Ï€")
plt.legend()
plt.grid(True)
plt.show()
'''

from scipy.linalg import solve
import numpy as np
import matplotlib.pyplot as plt

def cubic_spline(x, f, xt):
    """Natural cubic spline interpolation"""
    x = np.array(x, dtype=float)
    f = np.array(f, dtype=float)
    n = len(x)

    A = np.zeros((n, n))
    b = np.zeros(n)

    # Natural spline boundary conditions
    A[0, 0] = 1
    A[n - 1, n - 1] = 1
    b[0] = 0
    b[n - 1] = 0

    # Fill the system
    for i in range(1, n - 1):
        A[i, i - 1] = x[i] - x[i - 1]
        A[i, i] = 2 * (x[i + 1] - x[i - 1])
        A[i, i + 1] = x[i + 1] - x[i]
        b[i] = 6 * (
            (f[i + 1] - f[i]) / (x[i + 1] - x[i])
            - (f[i] - f[i - 1]) / (x[i] - x[i - 1])
        )

    # Solve for second derivatives
    f_double_prime = solve(A, b)

    # Vectorize to handle multiple xt
    xt = np.atleast_1d(xt)
    results = []

    for x_val in xt:
        if x_val <= x[0]:
            i = 0
        elif x_val >= x[-1]:
            i = n - 2
        else:
            i = np.searchsorted(x[1:], x_val)
        i = min(max(i, 0), n - 2)

        xi_minus_x = x_val - x[i]
        xi_plus_1_minus_x = x[i + 1] - x_val
        xi_plus_1_minus_xi = x[i + 1] - x[i]

        s_val = (
            f_double_prime[i] / (6 * xi_plus_1_minus_xi) * (xi_plus_1_minus_x) ** 3
            + f_double_prime[i + 1] / (6 * xi_plus_1_minus_xi) * (xi_minus_x) ** 3
            + (f[i] / xi_plus_1_minus_xi - f_double_prime[i] * xi_plus_1_minus_xi / 6)
            * xi_plus_1_minus_x
            + (f[i + 1] / xi_plus_1_minus_xi - f_double_prime[i + 1] * xi_plus_1_minus_xi / 6)
            * xi_minus_x
        )
        results.append(s_val)

    return results if len(results) > 1 else results[0]


# ---------------- Example Usage ----------------
if __name__ == "__main__":
    # Known data points
    x = [0, 1, 2, 3, 4]
    f = [0, 1, 0, 1, 0]   # A wavy function

    # Interpolation points
    xt = np.linspace(0, 4, 100)
    yt = cubic_spline(x, f, xt)

    # Plot
    plt.plot(x, f, 'ro', label="Data points")
    plt.plot(xt, yt, 'b-', label="Cubic spline")
    plt.legend()
    plt.xlabel("x")
    plt.ylabel("f(x)")
    plt.title("Natural Cubic Spline Interpolation")
    plt.grid(True)
    plt.show()
