import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def calculate_moving_averages(data, window_size=4):
  
    n = len(data)
    
    #  Calculate the 4-Quarter Moving Total
    moving_total = []
    for i in range(n - window_size + 1):
        total = sum(data[i : i + window_size])
        moving_total.append(total)
        
    # Calculate the 4-Quarter Moving Average
    moving_average = [total / window_size for total in moving_total]
    
    #  Center the Moving Average
    centered_moving_avg = []
    for i in range(len(moving_average) - 1):
        centered_avg = (moving_average[i] + moving_average[i+1]) / 2
        centered_moving_avg.append(centered_avg)
        
    return centered_moving_avg, moving_total, moving_average

def calculate_seasonal_indices(actual_data, centered_moving_avg):
    # Calculate the percentage of actual value to moving average
    percentage_actual_to_ma = []
    for i in range(len(centered_moving_avg)):
        ratio = (actual_data[i+2] / centered_moving_avg[i]) * 100
        percentage_actual_to_ma.append(round(ratio, 3))

    # Group the percentages by quarter to find the average effect
    quarters = [[], [], [], []] 
  
    for i, perc in enumerate(percentage_actual_to_ma):
        quarter_index = (i + 2) % 4
        if quarter_index == 2: quarters[0].append(perc) 
        elif quarter_index == 3: quarters[1].append(perc) 
        elif quarter_index == 0: quarters[2].append(perc) 
        elif quarter_index == 1: quarters[3].append(perc) 

    # Calculate the Modified Mean for each quarter
    
    modified_mean = []
    for q_data in quarters:
        if len(q_data) > 2:
            mean = (sum(q_data) - max(q_data) - min(q_data)) / (len(q_data) - 2)
        else: 
            mean = sum(q_data) / len(q_data) if q_data else 0
        modified_mean.append(round(mean, 3))

    # Adjust the indices to sum to 400
   
    total_modified_mean = sum(modified_mean)
    adjustment_factor = 400 / total_modified_mean if total_modified_mean != 0 else 1
    
    seasonal_indices = [round(mean * adjustment_factor, 3) for mean in modified_mean]
    
    return seasonal_indices, percentage_actual_to_ma, quarters, modified_mean, adjustment_factor

def calculate_trend_and_cyclic(deseasonalized_data):
  
    n = len(deseasonalized_data)
    
    X = [i - (n - 1) / 2 for i in range(n)]

    XY = [x * y for x, y in zip(X, deseasonalized_data)]
    X2 = [x**2 for x in X]
    
    b = sum(XY) / sum(X2) if sum(X2) != 0 else 0
    a = sum(deseasonalized_data) / n
    
    trend_values = [a + b * x for x in X]
    
    cyclic_variation = [(y / y_pred) * 100 for y, y_pred in zip(deseasonalized_data, trend_values)]
    
    return a, b, trend_values, cyclic_variation, X, XY, X2

def main():
 
    years = [1992, 1993, 1994, 1995]
    actual_values = [293, 246, 231, 282, 301, 252, 227, 291, 304, 259, 239, 296, 306, 265, 240, 300]
    n = len(actual_values)
    
    # Calculate Moving Averages
    centered_ma, moving_total, moving_avg = calculate_moving_averages(actual_values)
    
    # Calculate Seasonal Component
    seasonal_indices, percentage_ratio, quarters_grouped, modified_means, adj_factor = \
        calculate_seasonal_indices(actual_values, centered_ma)

    # Deseasonalize the Data
    deseasonalized_data = []
    for i in range(n):
        seasonal_factor = seasonal_indices[i % 4] / 100
        deseasonalized_data.append(round(actual_values[i] / seasonal_factor, 3))
        
    # Calculate Trend and Cyclic Components
    a, b, trend_line, cyclic_var, X, XY, X2 = calculate_trend_and_cyclic(deseasonalized_data)

    # Display Results in Tables
    display_results(
        years, actual_values, moving_total, moving_avg, centered_ma, percentage_ratio,
        quarters_grouped, modified_means, adj_factor, seasonal_indices,
        deseasonalized_data, a, b, trend_line, cyclic_var, X, XY, X2
    )
    
    # Plot the Data
    plot_data(years, actual_values, deseasonalized_data, trend_line, centered_ma)

def display_results(years, yVal, mov_tot, mov_avg, cent_mov_avg, perc_ratio, q_grouped,
                    mod_means, adj_factor, seas_indices, deseason_data, a, b, y_pred,
                    cyc_var, X, XY, X2):
   
    year_display = [y for y in years for _ in range(4)]
    quarter_labels = ['Q1', 'Q2', 'Q3', 'Q4'] * len(years)

    # Moving Averages and Ratios
    table1 = pd.DataFrame({
        "Year": year_display,
        "Quarter": quarter_labels,
        "Actual Value": yVal,
        "Moving Total": [''] * 2 + mov_tot + [''] * 1,
        "Moving Average": [''] * 2 + mov_avg + [''] * 1,
        "Centered Moving Avg": [''] * 2 + cent_mov_avg + [''] * 2,
        "Ratio (Actual/CMA)": [''] * 2 + perc_ratio + [''] * 2
    })
    print("Table 1: Calculation of Moving Averages and Ratios")
    print(table1.to_string())

    # Calculating Seasonal Indices
    table2_data = {}
    for i in range(4):
        
        col_data = q_grouped[i] + [''] * (len(years) - len(q_grouped[i]))
        table2_data[f"Quarter {i+1}"] = col_data
    
    table2 = pd.DataFrame(table2_data, index=years)
    table2.loc['Modified Sum'] = [round(sum(q) - max(q) - min(q), 3) if len(q)>2 else sum(q) for q in q_grouped]
    table2.loc['Modified Mean'] = mod_means
    print("\n--- Table 2: Grouping Ratios and Calculating Modified Mean ---")
    print(table2)

    print(f"\nAdjustment Factor: {adj_factor:.4f}")
    table3 = pd.DataFrame({
        "Quarter": ['Q1', 'Q2', 'Q3', 'Q4'],
        "Modified Mean": mod_means,
        "Seasonal Index": seas_indices
    })
    print("\n--- Table 3: Final Seasonal Indices ---")
    print(table3)
    print(f"Sum of seasonal indices: {sum(seas_indices):.1f}")
    
    # Deseasonalized Data
    table4 = pd.DataFrame({
        "Year": year_display,
        "Quarter": quarter_labels,
        "Actual Value": yVal,
        "Seasonal Index": seas_indices * len(years),
        "Deseasonalized Data": deseason_data
    })
    print("\n--- Table 4: Deseasonalized Time Series ---")
    print(table4.to_string())

    # Trend Calculation
    table5 = pd.DataFrame({
        "Year": year_display,
        "Quarter": quarter_labels,
        "Deseasonalized (Y)": deseason_data,
        "Time (X)": X,
        "XY": XY,
        "X^2": X2
    })
    print("\n--- Table 5: Trend Component Calculation ---")
    print(table5.to_string())
    print(f"\nTrend Line Equation: Y = {a:.3f} + {b:.3f}X")

    # Cyclic Variation
    table6 = pd.DataFrame({
        "Year": year_display,
        "Quarter": quarter_labels,
        "Deseasonalized (Y)": deseason_data,
        "Trend Value (Y_pred)": [round(y, 3) for y in y_pred],
        "Cyclic Var (%)": [round(c, 3) for c in cyc_var]
    })
    print("\n--- Table 6: Cyclic Variation Calculation ---")
    print(table6.to_string())

def plot_data(years, actual, deseasonalized, trend, centered_ma):
    
    labels = [f"{yr} {q}" for yr in years for q in ['Q1', 'Q2', 'Q3', 'Q4']]
    
    plt.figure(figsize=(14, 8))
    
   
    plt.plot(labels, actual, marker='o', linestyle='-', label="Actual Data")
    plt.plot(labels, deseasonalized, marker='s', linestyle='--', label="Deseasonalized Data")
    plt.plot(labels, trend, marker='x', linestyle=':', color='red', label="Trend Line")
    
   
    padded_ma = [np.nan, np.nan] + centered_ma + [np.nan, np.nan]
    plt.plot(labels, padded_ma, marker='d', linestyle='-.', color='green', label="Centered Moving Average")

    plt.title("Time Series Decomposition Analysis", fontsize=16)
    plt.xlabel("Year and Quarter", fontsize=12)
    plt.ylabel("Values", fontsize=12)
    plt.xticks(rotation=45, ha="right")
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout() 
    plt.show()

if __name__ == "__main__":
    main()

######################################################################

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

def calculate_acf(series, max_lag):
    n = len(series)
    series_mean = series.mean()
    
    autocovariances = []
    for k in range(max_lag + 1):
        shifted_series = series.shift(k)
        
        numerator = ((series - series_mean) * (shifted_series - series_mean)).sum()
        
        covariance = numerator / n
        autocovariances.append(covariance)
        
    variance = autocovariances[0]
    
    acf_values = [cov / variance for cov in autocovariances]
    
    return acf_values, autocovariances

def calculate_pacf(acf_values, max_lag):
    pacf_values = [1.0]
    
    for k in range(1, max_lag + 1):
        P_k = np.zeros((k, k))
        for i in range(k):
            for j in range(k):
                P_k[i, j] = acf_values[abs(i - j)]
        
        rho_k = np.array(acf_values[1 : k + 1])
        
        try:
            phi_k = np.linalg.solve(P_k, rho_k)
          
            pacf_at_k = phi_k[-1]
            pacf_values.append(pacf_at_k)
        except np.linalg.LinAlgError:
          
            pacf_values.append(np.nan)
            
    return pacf_values

def perform_significance_testing(values, n, title):
    
    conf_limit = 2 / np.sqrt(n)
    
    print(f"\n--- {title} VALUES WITH SIGNIFICANCE TESTING ---")
    print("=" * 65)
    print(f"{'Lag':<6} {title:<10} {'Significant?':<12} {'Decision':<40}")
    print("-" * 65)
    
    for lag, val in enumerate(values):
        if lag == 0:
            significant, decision = "N/A", f"{title}(0) = 1 (by definition)"
        else:
            if abs(val) > conf_limit:
                significant = "Yes"
                decision = "Reject H0: Correlation is significant"
            else:
                significant = "No"
                decision = "Fail to reject H0: Not significant"
        print(f"{lag:<6} {val:<10.4f} {significant:<12} {decision:<40}")

def plot_correlation(values, n, title, ylabel):
    
    conf_limit = 2 / np.sqrt(n)
    lags = range(len(values))
    
    plt.figure(figsize=(10, 6))
    
    plt.stem(lags, values)
    
    plt.axhline(0, color='black', linewidth=0.8)
    
    plt.axhline(conf_limit, color='red', linestyle='--', linewidth=1, label='95% Confidence Interval')
    plt.axhline(-conf_limit, color='red', linestyle='--', linewidth=1)
    
    plt.title(title, fontsize=16)
    plt.xlabel("Lag", fontsize=12)
    plt.ylabel(ylabel, fontsize=12)
    plt.xticks(np.arange(0, len(values), 2))
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.show()

def main():
    
    y_series = pd.Series([
        29, 20, 25, 29, 31, 33, 34, 27, 26, 30,
        29, 28, 28, 26, 27, 26, 30, 28, 26, 30,
        31, 30, 37, 30, 33, 31, 27, 33, 37, 29,
        28, 30, 29, 34, 30, 20, 17, 23, 24, 34,
        36, 35, 33, 29, 25, 27, 30, 29, 28, 32
    ])
    max_lag = 25
    n_observations = len(y_series)

    acf, covariances = calculate_acf(y_series, max_lag)
    
    pacf = calculate_pacf(acf, max_lag)
    
    print("--- Summary of ACF and PACF Calculations ---")
    results_df = pd.DataFrame({
        'Lag': range(max_lag + 1),
        'Autocovariance': covariances,
        'ACF': acf,
        'PACF': pacf
    })
    print(results_df.to_string(index=False, float_format="%.4f"))
    
    perform_significance_testing(acf, n_observations, "ACF")
    perform_significance_testing(pacf, n_observations, "PACF")

    plot_correlation(acf, n_observations, 'Autocorrelation Function (ACF)', 'ACF Value')
    plot_correlation(pacf, n_observations, 'Partial Autocorrelation Function (PACF)', 'PACF Value')

if __name__ == "__main__":
    main()

#####################################################

    import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import t

def single_exponential_smoothing(series, alpha, initial_value=None):
    
    smoothed_series = np.zeros(len(series))
    
    if initial_value is None:
        smoothed_series[0] = series[0]
    else:
        smoothed_series[0] = initial_value
        
    for t in range(1, len(series)):
        smoothed_series[t] = alpha * series[t] + (1 - alpha) * smoothed_series[t-1]
        
    return smoothed_series

def double_exponential_smoothing(series, alpha, initial_value=None):
    
    s1 = single_exponential_smoothing(series, alpha, initial_value)
    
    s2 = single_exponential_smoothing(s1, alpha, initial_value)
    
    final_forecast = 2 * s1 - s2
    
    return s1, s2, final_forecast

def perform_paired_ttest(original_data, forecasted_data, forecast_label, significance_level=0.05):
    
    errors = np.array(original_data) - np.array(forecasted_data)
    
    n = len(errors)
    mean_error = np.mean(errors)
    std_dev_error = np.std(errors, ddof=1)
    
    t_statistic = mean_error / (std_dev_error / np.sqrt(n))
    
    p_value = 2 * t.sf(np.abs(t_statistic), df=n-1)
    
    print(f"\n--- T-Test Results for: {forecast_label} ---")
    print(f"Mean Forecast Error: {mean_error:.4f}")
    print(f"t-statistic: {t_statistic:.4f}")
    print(f"p-value: {p_value:.4f}")
  
    if p_value < significance_level:
        print(f"Conclusion: Reject H0. The forecast is significantly biased (p < {significance_level}).")
    else:
        print(f"Conclusion: Fail to reject H0. The forecast is not significantly biased (p >= {significance_level}).")

def plot_smoothing_results(periods, original, smoothed_results, title):
  
    plt.figure(figsize=(12, 7))
    plt.plot(periods, original, 'o-', color='black', label='Original Data')
    
    for label, data in smoothed_results.items():
        plt.plot(periods, data, 'o--', label=label)
        
    plt.title(title, fontsize=16)
    plt.xlabel("Time Period", fontsize=12)
    plt.ylabel("Value", fontsize=12)
    plt.xticks(periods, rotation=45)
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()
    plt.show()

def main():
    
    periods = np.arange(1, 25)
    yt = [
        315, 195, 310, 316, 325, 335, 318, 355, 420, 410, 485, 420,
        460, 395, 390, 450, 458, 570, 520, 400, 420, 580, 475, 560
    ]
    initial_y0 = yt[0]

    alphas = [0.2, 0.4]
    
    results = {}
    for alpha in alphas:
       
        results[f'single_a={alpha}'] = single_exponential_smoothing(yt, alpha, initial_y0)
        
        s1, s2, final = double_exponential_smoothing(yt, alpha, initial_y0)
        results[f'double_final_a={alpha}'] = final

    table_data = {'Period': periods, 'Original': yt}
    table_data.update({f'Single (α={a})': results[f'single_a={a}'] for a in alphas})
    table_data.update({f'Double (α={a})': results[f'double_final_a={a}'] for a in alphas})
    
    results_df = pd.DataFrame(table_data)
    print("--- Summary of Exponential Smoothing Results ---")
    print(results_df.round(2).to_string(index=False))

    plot_smoothing_results(
        periods, yt, 
        {f'Single Smoothed (α={a})': results[f'single_a={a}'] for a in alphas},
        'First-Order (Single) Exponential Smoothing'
    )
    
    plot_smoothing_results(
        periods, yt,
        {f'Double Smoothed (α={a})': results[f'double_final_a={a}'] for a in alphas},
        'Second-Order (Double) Exponential Smoothing'
    )
    
    for alpha in alphas:
        perform_paired_ttest(yt, results[f'single_a={alpha}'], f'Single Smoothing (α={alpha})')
        perform_paired_ttest(yt, results[f'double_final_a={alpha}'], f'Double Smoothing (α={alpha})')

if __name__ == "__main__":
    main()

#########################################################


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


fixed_data = {
    'Open':  [180, 182, 181, 185, 184, 187, 190, 188, 192, 191],
    'Close': [181, 181, 183, 184, 186, 189, 189, 190, 193, 190]
}

data = pd.DataFrame(fixed_data)

data["Rate of Return"] = (data["Close"] - data["Open"]) / data["Open"] * 100

print("--- Using Fixed 10-Point Sample Data ---")
print(data)
print("----------------------------------------\n")

def coded_variable(n):

    if n % 2 == 0:
        return np.arange(-n + 1, n, 2).astype(float)
    else:
        return np.arange(-(n // 2), n // 2 + 1).astype(float)

def fit_linear(y, x):

    a = np.mean(y)
    b = np.sum(x * y) / np.sum(x**2)
    y_pred = a + b * x
    return (a, b), y_pred

def fit_quadratic(y, x):

    n = len(y)
    sum_x2 = np.sum(x**2)
    sum_x4 = np.sum(x**4)
    sum_y  = np.sum(y)
    sum_x2y = np.sum(x**2 * y)

    b = np.sum(x * y) / sum_x2
    A = np.array([[n, sum_x2], [sum_x2, sum_x4]])
    B = np.array([sum_y, sum_x2y])
    a, c = np.linalg.solve(A, B)

    y_pred = a + b * x + c * (x**2)
    return (a, b, c), y_pred

def fit_cubic(y, x):

    X = np.vstack([np.ones_like(x), x, x**2, x**3]).T
  
    coeffs = np.linalg.inv(X.T @ X) @ (X.T @ y)
    y_pred = X @ coeffs
    return tuple(coeffs), y_pred

def error_analysis(y, y_pred):
    """Calculates common error metrics for a model."""
    resid = y - y_pred
    rmse = np.sqrt(np.mean(resid**2))
    mape = np.mean(np.abs(resid / y)) * 100
    r2 = 1 - np.sum(resid**2) / np.sum((y - np.mean(y))**2)
    return rmse, mape, r2

variables = {
    "Opening Stock Price": data["Open"].values,
    "Closing Stock Price": data["Close"].values,
    "Rate of Return (%)": data["Rate of Return"].values
}

trend_types = ["Linear", "Quadratic", "Cubic"]
results_table = []


fig, axes = plt.subplots(3, 1, figsize=(12, 12), sharex=True)
fig.suptitle("Secular Trend Fits for Sample Stock Data", fontsize=16)

for row, (var_name, y) in enumerate(variables.items()):
    x = coded_variable(len(y))
    ax = axes[row]
    ax.plot(range(len(y)), y, marker="o", linestyle='-', color="black", alpha=0.7, label="Actual Data")

    for trend in trend_types:
        if trend == "Linear":
            coeffs, y_pred = fit_linear(y, x)
        elif trend == "Quadratic":
            coeffs, y_pred = fit_quadratic(y, x)
        else: 
            coeffs, y_pred = fit_cubic(y, x)

        rmse, mape, r2 = error_analysis(y, y_pred)
        results_table.append({
            "Variable": var_name,
            "Trend": trend,
            "Coefficients": np.round(coeffs, 4),
            "RMSE": round(rmse, 4),
            "R-squared": round(r2, 4)
        })

        ax.plot(range(len(y)), y_pred, lw=2, label=f"{trend} Fit")

    ax.set_title(var_name)
    ax.set_ylabel(var_name)
    ax.legend(fontsize=9)
    ax.grid(True, linestyle='--', alpha=0.5)
    ax.set_xticks(range(len(y))) 

axes[-1].set_xlabel("Observation Index (Time)")
plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()


results_df = pd.DataFrame(results_table)
print("\n--- Secular Trend Model Results ---")
print(results_df.to_string())
